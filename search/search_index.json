{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Writeup Dr4g0n B4ll Esta documentaci\u00f3n esta hecha con la intenci\u00f3n de que aquellas personas que no tengan experiencia propia puedan introducirse en el Hacking y sobretodo que conozcan las Fases de un Ejercicio de Red Team a la hora de comprometer una m\u00e1quina. Autor principal Antonio S\u00e1nchez Moscoso Linkedin","title":"Inicio"},{"location":"#writeup-dr4g0n-b4ll","text":"Esta documentaci\u00f3n esta hecha con la intenci\u00f3n de que aquellas personas que no tengan experiencia propia puedan introducirse en el Hacking y sobretodo que conozcan las Fases de un Ejercicio de Red Team a la hora de comprometer una m\u00e1quina.","title":"Writeup Dr4g0n B4ll"},{"location":"#autor-principal","text":"Antonio S\u00e1nchez Moscoso Linkedin","title":"Autor principal"},{"location":"dragonball/","text":"Writeup - Dr4G0n B4ll Configuraci\u00f3n del Laboratorio Necesitaremos tener instalado: - M\u00e1quina Parrot o Kali (M\u00e1quina Atacante) - M\u00e1quinta Dr4g0n B4ll (M\u00e1quina V\u00edctima) -> https://mega.nz/file/AoJ3EAhI#WIMxmfUXh_vr6C5lGqeCbmKOrNrJU6rB1mMc4wS7F24 Una vez tenemos nuestras m\u00e1quinas en nuestro sistema de Virtualizaci\u00f3n, vamos a configurar nuestra Red en ambas m\u00e1quinas con la misma configuraci\u00f3n, en este caso, NAT . Descubrimiento del Equipo V\u00edctima Para descubrir los distintos equipos que tenemos en nuestra red lo podemos hacer de dos formas distintas: - fping : fping es una peque\u00f1a herramienta de l\u00ednea de comandos para enviar solicitudes de echo ICMP (Internet Control Message Protocol) a hosts de la red, similar a ping, pero con un rendimiento mucho mayor cuando se hace ping a m\u00faltiples hosts. - netdiscover : Netdiscover al igual que fping sirve para describir equipos dentro de un rango de red pero usando el protocolo ARP. Veremos que se realiza con ambos comandos la identificaci\u00f3n del equipo v\u00edctima. Para ello primero tenemos que ver la IP de nuestra m\u00e1quina atacante. Como vemos en la imagen, la ip es la siguiente 192.168.194.132 , por tanto, y teniendo nuestra m\u00e1quina Dr4g0n B4ll arrancada, empezamos con el descubrimiento de equipos. Observamos que nos ha encontrado dos equipos pero si descartamos el primero que es nuestro Gateway , s\u00f3lo tendr\u00edamos el acabado en 137 que tiene pinta a ser nuestra m\u00e1quina v\u00edctima. Comprobemos con netdiscover para cerciorarnos. netdiscover -r 192.168.194.0/24 Efectivamente vemos que nos encontramos con la m\u00e1quina 137. Por tanto, vamos a pasar a la fase de escaneo con esta IP. Fase de Escaneo y Enumeraci\u00f3n La siguiente fase es la de escanear los puertos y servicios que corren en esta m\u00e1quina. Para ello haremos uso de Nmap . En mi caso, siempre me gusta realizar dos tipos de escaneos, uno exclusivo de los puertos y una vez obtenidos los puertos, realizar otro para averiguar los servicios y versiones espec\u00edficos que corren para esos puertos. Primer comando Nmap: nmap -p- --open -T5 -v -n 192.168.194.137 -p-: Escaneamos todos los puertos --open: S\u00f3lo los puertos con estado Abierto. -T5: Nivel de agresividad para hacer el escaneo en el env\u00edo de paquetes siendo 5 el m\u00e1s alto (Recomendable siempre y cuando sea en entornos controlados.) -v: Verbose para ver el output del comando en tiempo real. -n: Evitar la resoluci\u00f3n DNS Esperamos a que termine el escaneo pero a priori ya podemos ver que se encuentran el puerto 80 y 22 abiertos . Nos encontramos exclusivamente con los puertos 22 y 80 abiertos, ahora vamos a proceder a analizar las versiones que corren tras estos servicios SSH y HTTP respectivamente. nmap -p22,80 -sCV -v 192.168.194.137 Vemos que en el puerto 22 nos encontramos con un OpenSSH 7.9p1 y que en el puerto 80 tenemos un Apache httpd 2.4.38 . Al tener un puerto 80 abierto vamos a ir a la web para analizar m\u00e1s en detalle y seguir con la enumeraci\u00f3n. Para trabajar m\u00e1s c\u00f3modos vamos a asignar a nuestra IP V\u00edctima un DNS en nuestro archivo /etc/hosts Ahora vamos a nuestro navegador y busquemos por la siguiente URL: http://dragonball.uco Vemos que nos muestra un portal web con una imagen de Dragon Ball. Llegados a este punto suelo realizar 3 apartados que sigo siempre en un portal web: Revisar la tecnolog\u00eda usada con el Addon Wappalyzer para seguir obteniendo informaci\u00f3n del servicio ya que podr\u00eda usar tecnolog\u00eda con versiones desactualizas. Analizar el c\u00f3digo fuente. Revisar el fichero Robots.txt Empezemos viendo Wappalyzer: En este caso no nos ofrece m\u00e1s informaci\u00f3n de la que ya sab\u00edamos. Pasemos al siguiente paso (analizar el c\u00f3digo fuente de la web): Analizando el c\u00f3digo fuente no vemos nada raro pero observamos por el scrollbar que posee demasiada longitud para el contenido que tiene la web, vayamos bajando... Bingo!! Encontramos un mensaje codificado. Si tenemos cierta experiencia nos podemos dar cuenta de que se parece bastante a un Base64 pero con la peculiaridad de que no aparecen los dos iguales al final... Por lo que podemos suponer que igual es un Base64 concatenado varias veces. Para ello vamos utilizar la herramienta Cyberchef https://gchq.github.io/CyberChef/ En este caso, usaremos Magic que nos permite especificar el n\u00famero de repeticiones. Con una repetici\u00f3n de 3 veces, hemos encontrado en texto claro la palabra DRAGON BALL . A priori no nos dice nada, pero sigamos con nuestros pasos establecidos y ya veremos como proseguimos despu\u00e9s. El siguiente y \u00faltimo paso es analizar el archivo robots.txt . Nos volvemos a encontrar con lo que parece un mensaje codificado en Base64, pero esta vez m\u00e1s parecido a la sintaxis de un Base64. Procedamos a decodificar el mensaje. echo -n \"<mensaje>\" | base64 -d \"Encuentra el directorio oculto\".... Nosotros previamente hab\u00edamos encontrado una palabra sospechosa, \u00bfpodr\u00eda ser un directorio oculto? Probemos a introducirlo en la URL. Efectivamente, es un directorio que contiene un secret.txt y una carpeta llamada vulnhub . Analicemos previamente el secret.txt que tiene m\u00e1s pinta de haber algo interesante... Una lista de directorios... A priori me llama el username y passwd , comprobemos si existen... Fase de Explotaci\u00f3n Nada... y he seguido comprobando y pasar\u00eda lo mismo con el resto de los directorios. Okey, pasemos a la carpeta Vulnhub a ver si de ah\u00ed encontramos algo interesante... Nos encontramos con una imagen y un login... La imagen vamos a verla y posteriormente a analizar con herramientas de esteganograf\u00eda por si tuviera algo oculto... Vemos que es una imagen normal pero un tanto peculiar, vamos a descargarla y ver si conlleva algo dentro usando la herramienta de Stego Stegseek que nos permite comprobar si existe alg\u00fan fichero oculto en su interior utilizando un Diccionario para aplicar fuerza bruta. wget <enlace> stegseek aj.jpg /usr/share/wordlists/rockyou.txt Boom!! Nos encontramos con una clave privada id_rsa gracias a la herramienta stegseek y la palabra para descargar el archivo oculto resultaba ser love . Al extraerlo se nos ha guardado con el nombre aj.jpg.out , vamos a cambiarlo a id_rsa . mv aj.jpg.out id_rsa Vale, tenemos una clave pero nos falta un usuario potencial... Si recordamos nos falt\u00f3 por analizar el login.html veamos el contenido de esta p\u00e1gina. Al analizar la p\u00e1gina podemos ver que dice Welcome to xmen , por lo que parece ser que xmen puede ser un usuario potencial. Comprobemos si nos podemos conectar por ssh usando la clave privada a este usuario. Nos aparece un error de que los permisos asignados a la clave privada id_rsa no son los correctos, vayamos a googlear y comprobar qu\u00e9 permisos debemos de asignarle... Efectivamente, tenemos que asignarle al archivo el permiso 600... chmod 600 id_rsa Ahora con el permiso correctamente asignado, veamos si podemos acceder por ssh al usuario xmen. Entramos al sistema como el usuario xmen!!! Ahora bien, necesitamos ser root. Fase de Escalada de Privilegios Vamos a comprobar en el usuario xmen los binarios SUID que tiene habilitados. Para ello, escribimos lo siguiente: find \\ /-perm -4000 2>/dev/null Nos encotramos algo curioso y es que dentro del usuario xmen y dentro de la carpeta script, tenemos un binario llamado shell con permisos SUID, ve\u00e1mos qu\u00e9 ejecuta este binario. Nos est\u00e1 ejecutando el comando de sistema PS . Adem\u00e1s justo en la misma carpeta tenemos demo.c que parece ser que ha sido el programa con el que se ha compilado shell . Efectivamente, est\u00e1 llamando al comando del sistema ps . LLegados a este punto vamos a proceder a hacer un Path Hijacking , es decir, un secuestro del PATH. Para ello lo que vamos a crear es un fichero ejectuable llamado ps y cambiaremos el PATH indic\u00e1ndole que como primera ruta a ejecutar sea donde nosotros tenemos el fichero ps que lo que habr\u00e1 escrito ser\u00e1 lo siguiente: bash -p Lo que nos permite es que al ser un binario SUID nos ejecuta los ficheros de forma temporal siendo el usuario propietario del archivo, es decir, root. Por tanto vamos a proceder a realizar el Path Hijacking. Comprobamos previamente que el binario shell tiene como propietario a root. Ahora vamos a crear el fichero y le damos permisos de ejecuci\u00f3n con chmod +x ps No podemos crear el fichero aqu\u00ed ya que el propietario es root, por lo que podemos ir a la carpeta /tmp/ o a nuestro /home/ ya que ah\u00ed si podemos crear el fichero. En mi caso, ir\u00e9 a la carpeta tmp . Creamos el fichero, le asignamos permisos de ejecuci\u00f3n y en el PATH indicamos que inicie desde la carpeta tmp, de este modo, cuando ejecutemos el comando ps empezar\u00e1 a ejecutar cualquier binario llamado ps desde la carpeta /tmp/, por tanto, ejecutar\u00e1 bash -p con el objetivo de convertirnos en root. Nos vamos a la carpeta script y ejecutamos shell . Finalmente somos ROOT!!! Espero que os haya gustado la m\u00e1quina y hay\u00e1is aprendido, al menos que os qued\u00e9is con lo m\u00e1s importante que es entender como funciona el Path Hijacking .","title":"Resolution"},{"location":"dragonball/#writeup-dr4g0n-b4ll","text":"","title":"Writeup - Dr4G0n B4ll"},{"location":"dragonball/#configuracion-del-laboratorio","text":"Necesitaremos tener instalado: - M\u00e1quina Parrot o Kali (M\u00e1quina Atacante) - M\u00e1quinta Dr4g0n B4ll (M\u00e1quina V\u00edctima) -> https://mega.nz/file/AoJ3EAhI#WIMxmfUXh_vr6C5lGqeCbmKOrNrJU6rB1mMc4wS7F24 Una vez tenemos nuestras m\u00e1quinas en nuestro sistema de Virtualizaci\u00f3n, vamos a configurar nuestra Red en ambas m\u00e1quinas con la misma configuraci\u00f3n, en este caso, NAT .","title":"Configuraci\u00f3n del Laboratorio"},{"location":"dragonball/#descubrimiento-del-equipo-victima","text":"Para descubrir los distintos equipos que tenemos en nuestra red lo podemos hacer de dos formas distintas: - fping : fping es una peque\u00f1a herramienta de l\u00ednea de comandos para enviar solicitudes de echo ICMP (Internet Control Message Protocol) a hosts de la red, similar a ping, pero con un rendimiento mucho mayor cuando se hace ping a m\u00faltiples hosts. - netdiscover : Netdiscover al igual que fping sirve para describir equipos dentro de un rango de red pero usando el protocolo ARP. Veremos que se realiza con ambos comandos la identificaci\u00f3n del equipo v\u00edctima. Para ello primero tenemos que ver la IP de nuestra m\u00e1quina atacante. Como vemos en la imagen, la ip es la siguiente 192.168.194.132 , por tanto, y teniendo nuestra m\u00e1quina Dr4g0n B4ll arrancada, empezamos con el descubrimiento de equipos. Observamos que nos ha encontrado dos equipos pero si descartamos el primero que es nuestro Gateway , s\u00f3lo tendr\u00edamos el acabado en 137 que tiene pinta a ser nuestra m\u00e1quina v\u00edctima. Comprobemos con netdiscover para cerciorarnos. netdiscover -r 192.168.194.0/24 Efectivamente vemos que nos encontramos con la m\u00e1quina 137. Por tanto, vamos a pasar a la fase de escaneo con esta IP.","title":"Descubrimiento del Equipo V\u00edctima"},{"location":"dragonball/#fase-de-escaneo-y-enumeracion","text":"La siguiente fase es la de escanear los puertos y servicios que corren en esta m\u00e1quina. Para ello haremos uso de Nmap . En mi caso, siempre me gusta realizar dos tipos de escaneos, uno exclusivo de los puertos y una vez obtenidos los puertos, realizar otro para averiguar los servicios y versiones espec\u00edficos que corren para esos puertos. Primer comando Nmap: nmap -p- --open -T5 -v -n 192.168.194.137 -p-: Escaneamos todos los puertos --open: S\u00f3lo los puertos con estado Abierto. -T5: Nivel de agresividad para hacer el escaneo en el env\u00edo de paquetes siendo 5 el m\u00e1s alto (Recomendable siempre y cuando sea en entornos controlados.) -v: Verbose para ver el output del comando en tiempo real. -n: Evitar la resoluci\u00f3n DNS Esperamos a que termine el escaneo pero a priori ya podemos ver que se encuentran el puerto 80 y 22 abiertos . Nos encontramos exclusivamente con los puertos 22 y 80 abiertos, ahora vamos a proceder a analizar las versiones que corren tras estos servicios SSH y HTTP respectivamente. nmap -p22,80 -sCV -v 192.168.194.137 Vemos que en el puerto 22 nos encontramos con un OpenSSH 7.9p1 y que en el puerto 80 tenemos un Apache httpd 2.4.38 . Al tener un puerto 80 abierto vamos a ir a la web para analizar m\u00e1s en detalle y seguir con la enumeraci\u00f3n. Para trabajar m\u00e1s c\u00f3modos vamos a asignar a nuestra IP V\u00edctima un DNS en nuestro archivo /etc/hosts Ahora vamos a nuestro navegador y busquemos por la siguiente URL: http://dragonball.uco Vemos que nos muestra un portal web con una imagen de Dragon Ball. Llegados a este punto suelo realizar 3 apartados que sigo siempre en un portal web: Revisar la tecnolog\u00eda usada con el Addon Wappalyzer para seguir obteniendo informaci\u00f3n del servicio ya que podr\u00eda usar tecnolog\u00eda con versiones desactualizas. Analizar el c\u00f3digo fuente. Revisar el fichero Robots.txt Empezemos viendo Wappalyzer: En este caso no nos ofrece m\u00e1s informaci\u00f3n de la que ya sab\u00edamos. Pasemos al siguiente paso (analizar el c\u00f3digo fuente de la web): Analizando el c\u00f3digo fuente no vemos nada raro pero observamos por el scrollbar que posee demasiada longitud para el contenido que tiene la web, vayamos bajando... Bingo!! Encontramos un mensaje codificado. Si tenemos cierta experiencia nos podemos dar cuenta de que se parece bastante a un Base64 pero con la peculiaridad de que no aparecen los dos iguales al final... Por lo que podemos suponer que igual es un Base64 concatenado varias veces. Para ello vamos utilizar la herramienta Cyberchef https://gchq.github.io/CyberChef/ En este caso, usaremos Magic que nos permite especificar el n\u00famero de repeticiones. Con una repetici\u00f3n de 3 veces, hemos encontrado en texto claro la palabra DRAGON BALL . A priori no nos dice nada, pero sigamos con nuestros pasos establecidos y ya veremos como proseguimos despu\u00e9s. El siguiente y \u00faltimo paso es analizar el archivo robots.txt . Nos volvemos a encontrar con lo que parece un mensaje codificado en Base64, pero esta vez m\u00e1s parecido a la sintaxis de un Base64. Procedamos a decodificar el mensaje. echo -n \"<mensaje>\" | base64 -d \"Encuentra el directorio oculto\".... Nosotros previamente hab\u00edamos encontrado una palabra sospechosa, \u00bfpodr\u00eda ser un directorio oculto? Probemos a introducirlo en la URL. Efectivamente, es un directorio que contiene un secret.txt y una carpeta llamada vulnhub . Analicemos previamente el secret.txt que tiene m\u00e1s pinta de haber algo interesante... Una lista de directorios... A priori me llama el username y passwd , comprobemos si existen...","title":"Fase de Escaneo y Enumeraci\u00f3n"},{"location":"dragonball/#fase-de-explotacion","text":"Nada... y he seguido comprobando y pasar\u00eda lo mismo con el resto de los directorios. Okey, pasemos a la carpeta Vulnhub a ver si de ah\u00ed encontramos algo interesante... Nos encontramos con una imagen y un login... La imagen vamos a verla y posteriormente a analizar con herramientas de esteganograf\u00eda por si tuviera algo oculto... Vemos que es una imagen normal pero un tanto peculiar, vamos a descargarla y ver si conlleva algo dentro usando la herramienta de Stego Stegseek que nos permite comprobar si existe alg\u00fan fichero oculto en su interior utilizando un Diccionario para aplicar fuerza bruta. wget <enlace> stegseek aj.jpg /usr/share/wordlists/rockyou.txt Boom!! Nos encontramos con una clave privada id_rsa gracias a la herramienta stegseek y la palabra para descargar el archivo oculto resultaba ser love . Al extraerlo se nos ha guardado con el nombre aj.jpg.out , vamos a cambiarlo a id_rsa . mv aj.jpg.out id_rsa Vale, tenemos una clave pero nos falta un usuario potencial... Si recordamos nos falt\u00f3 por analizar el login.html veamos el contenido de esta p\u00e1gina. Al analizar la p\u00e1gina podemos ver que dice Welcome to xmen , por lo que parece ser que xmen puede ser un usuario potencial. Comprobemos si nos podemos conectar por ssh usando la clave privada a este usuario. Nos aparece un error de que los permisos asignados a la clave privada id_rsa no son los correctos, vayamos a googlear y comprobar qu\u00e9 permisos debemos de asignarle... Efectivamente, tenemos que asignarle al archivo el permiso 600... chmod 600 id_rsa Ahora con el permiso correctamente asignado, veamos si podemos acceder por ssh al usuario xmen. Entramos al sistema como el usuario xmen!!! Ahora bien, necesitamos ser root.","title":"Fase de Explotaci\u00f3n"},{"location":"dragonball/#fase-de-escalada-de-privilegios","text":"Vamos a comprobar en el usuario xmen los binarios SUID que tiene habilitados. Para ello, escribimos lo siguiente: find \\ /-perm -4000 2>/dev/null Nos encotramos algo curioso y es que dentro del usuario xmen y dentro de la carpeta script, tenemos un binario llamado shell con permisos SUID, ve\u00e1mos qu\u00e9 ejecuta este binario. Nos est\u00e1 ejecutando el comando de sistema PS . Adem\u00e1s justo en la misma carpeta tenemos demo.c que parece ser que ha sido el programa con el que se ha compilado shell . Efectivamente, est\u00e1 llamando al comando del sistema ps . LLegados a este punto vamos a proceder a hacer un Path Hijacking , es decir, un secuestro del PATH. Para ello lo que vamos a crear es un fichero ejectuable llamado ps y cambiaremos el PATH indic\u00e1ndole que como primera ruta a ejecutar sea donde nosotros tenemos el fichero ps que lo que habr\u00e1 escrito ser\u00e1 lo siguiente: bash -p Lo que nos permite es que al ser un binario SUID nos ejecuta los ficheros de forma temporal siendo el usuario propietario del archivo, es decir, root. Por tanto vamos a proceder a realizar el Path Hijacking. Comprobamos previamente que el binario shell tiene como propietario a root. Ahora vamos a crear el fichero y le damos permisos de ejecuci\u00f3n con chmod +x ps No podemos crear el fichero aqu\u00ed ya que el propietario es root, por lo que podemos ir a la carpeta /tmp/ o a nuestro /home/ ya que ah\u00ed si podemos crear el fichero. En mi caso, ir\u00e9 a la carpeta tmp . Creamos el fichero, le asignamos permisos de ejecuci\u00f3n y en el PATH indicamos que inicie desde la carpeta tmp, de este modo, cuando ejecutemos el comando ps empezar\u00e1 a ejecutar cualquier binario llamado ps desde la carpeta /tmp/, por tanto, ejecutar\u00e1 bash -p con el objetivo de convertirnos en root. Nos vamos a la carpeta script y ejecutamos shell . Finalmente somos ROOT!!! Espero que os haya gustado la m\u00e1quina y hay\u00e1is aprendido, al menos que os qued\u00e9is con lo m\u00e1s importante que es entender como funciona el Path Hijacking .","title":"Fase de Escalada de Privilegios"}]}